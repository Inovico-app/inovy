import { google } from "googleapis";
import { err, ok } from "neverthrow";
import { ActionErrors, type ActionResult } from "../../lib/action-errors";
import { assertOrganizationAccess } from "../../lib/organization-isolation";
import { createGoogleOAuthClient } from "../../lib/google-oauth";
import { logger } from "../../lib/logger";
import { AutoActionsQueries } from "../data-access";
import type { Recording } from "../db/schema";
import { GoogleOAuthService } from "./google-oauth.service";

/**
 * Google Gmail Service
 * Manages Gmail draft creation from recordings
 */
export class GoogleGmailService {
  /**
   * Create a Gmail draft from a recording summary
   */
  static async createDraftFromSummary(
    userId: string,
    organizationId: string,
    recording: Recording,
    summary: string,
    options?: {
      subject?: string;
      additionalContent?: string;
    }
  ): Promise<ActionResult<{ draftId: string; draftUrl: string }>> {
    try {
      // Verify recording belongs to organization
      try {
        assertOrganizationAccess(
          recording.organizationId,
          organizationId,
          "GoogleGmailService.createDraftFromSummary"
        );
      } catch (error) {
        return err(
          ActionErrors.notFound(
            "Recording not found",
            "GoogleGmailService.createDraftFromSummary"
          )
        );
      }

      // Get valid access token
      const tokenResult = await GoogleOAuthService.getValidAccessToken(userId);

      if (tokenResult.isErr()) {
        return err(
          ActionErrors.internal(
            "Failed to get valid access token",
            tokenResult.error,
            "GoogleGmailService.createDraftFromSummary"
          )
        );
      }

      const accessToken = tokenResult.value;

      // Create OAuth client with token
      const oauth2Client = createGoogleOAuthClient();
      oauth2Client.setCredentials({
        access_token: accessToken,
      });

      // Initialize Gmail API
      const gmail = google.gmail({ version: "v1", auth: oauth2Client });

      // Build email subject
      const subject = options?.subject ?? `Meeting Summary: ${recording.title}`;

      // Build email body in HTML
      let htmlBody = "<html><body style='font-family: Arial, sans-serif;'>";
      htmlBody += `<h2>${recording.title}</h2>`;

      // Add recording metadata
      htmlBody +=
        "<div style='color: #666; font-size: 14px; margin-bottom: 20px;'>";
      htmlBody += `<p><strong>Date:</strong> ${new Date(
        recording.createdAt
      ).toLocaleDateString("en-US", {
        weekday: "long",
        year: "numeric",
        month: "long",
        day: "numeric",
      })}</p>`;
      if (recording.duration) {
        const minutes = Math.floor(recording.duration / 60);
        htmlBody += `<p><strong>Duration:</strong> ${minutes} minutes</p>`;
      }
      htmlBody += "</div>";

      // Add summary content
      if (summary) {
        htmlBody += "<div style='margin-bottom: 20px;'>";
        htmlBody += "<h3>Summary</h3>";
        const summaryParagraphs = summary
          .split("\n\n")
          .map((p) => `<p>${p.trim()}</p>`)
          .join("");
        htmlBody += summaryParagraphs;
        htmlBody += "</div>";
      }

      // Add additional content if provided
      if (options?.additionalContent) {
        htmlBody += "<div style='margin-bottom: 20px;'>";
        htmlBody += options.additionalContent;
        htmlBody += "</div>";
      }

      // Add footer
      htmlBody +=
        "<hr style='border: none; border-top: 1px solid #ddd; margin: 30px 0;'>";
      htmlBody += "<div style='color: #999; font-size: 12px;'>";
      htmlBody += `<p>This summary was generated by Inovy.</p>`;
      htmlBody += `<p>Recording ID: ${recording.id}</p>`;
      htmlBody += "</div>";
      htmlBody += "</body></html>";

      // Create RFC 2822 formatted email
      const email = [
        `Subject: ${subject}`,
        "Content-Type: text/html; charset=utf-8",
        "MIME-Version: 1.0",
        "",
        htmlBody,
      ].join("\r\n");

      // Encode email in base64url format
      const encodedEmail = Buffer.from(email)
        .toString("base64")
        .replace(/\+/g, "-")
        .replace(/\//g, "_")
        .replace(/=+$/, "");

      // Create draft
      const response = await gmail.users.drafts.create({
        userId: "me",
        requestBody: {
          message: {
            raw: encodedEmail,
          },
        },
      });

      if (!response.data.id) {
        return err(
          ActionErrors.internal(
            "Failed to create Gmail draft - no draft ID returned",
            undefined,
            "GoogleGmailService.createDraftFromSummary"
          )
        );
      }

      const draftUrl = `https://mail.google.com/mail/u/0/#drafts?compose=${response.data.id}`;

      logger.info("Created Gmail draft from recording", {
        userId,
        recordingId: recording.id,
        draftId: response.data.id,
      });

      // Record the action via DAL
      await AutoActionsQueries.createAutoAction({
        userId,
        type: "email_draft",
        provider: "google",
        recordingId: recording.id,
        status: "completed",
        externalId: response.data.id,
        externalUrl: draftUrl,
        processedAt: new Date(),
      });

      return ok({
        draftId: response.data.id,
        draftUrl,
      });
    } catch (error) {
      const errorMessage = `Failed to create Gmail draft: ${
        error instanceof Error ? error.message : "Unknown error"
      }`;
      logger.error(
        errorMessage,
        { userId, recordingId: recording.id },
        error as Error
      );

      // Record failed action
      try {
        await AutoActionsQueries.createAutoAction({
          userId,
          type: "email_draft",
          provider: "google",
          recordingId: recording.id,
          status: "failed",
          errorMessage: errorMessage,
          processedAt: new Date(),
        });
      } catch (dbError) {
        logger.error("Failed to record failed action", {}, dbError as Error);
      }

      return err(
        ActionErrors.internal(
          errorMessage,
          error as Error,
          "GoogleGmailService.createDraftFromSummary"
        )
      );
    }
  }

  /**
   * Get draft details
   */
  static async getDraft(
    userId: string,
    draftId: string
  ): Promise<ActionResult<unknown>> {
    try {
      const tokenResult = await GoogleOAuthService.getValidAccessToken(userId);

      if (tokenResult.isErr()) {
        return err(
          ActionErrors.internal(
            "Failed to get valid access token",
            tokenResult.error,
            "GoogleGmailService.getDraft"
          )
        );
      }

      const accessToken = tokenResult.value;

      const oauth2Client = createGoogleOAuthClient();
      oauth2Client.setCredentials({
        access_token: accessToken,
      });

      const gmail = google.gmail({ version: "v1", auth: oauth2Client });

      const response = await gmail.users.drafts.get({
        userId: "me",
        id: draftId,
      });

      return ok(response.data);
    } catch (error) {
      logger.error(
        "Failed to get Gmail draft",
        { userId, draftId },
        error as Error
      );
      return err(
        ActionErrors.internal(
          "Failed to get Gmail draft",
          error as Error,
          "GoogleGmailService.getDraft"
        )
      );
    }
  }

  /**
   * Delete draft
   */
  static async deleteDraft(
    userId: string,
    draftId: string
  ): Promise<ActionResult<boolean>> {
    try {
      const tokenResult = await GoogleOAuthService.getValidAccessToken(userId);

      if (tokenResult.isErr()) {
        return err(
          ActionErrors.internal(
            "Failed to get valid access token",
            tokenResult.error,
            "GoogleGmailService.deleteDraft"
          )
        );
      }

      const accessToken = tokenResult.value;

      const oauth2Client = createGoogleOAuthClient();
      oauth2Client.setCredentials({
        access_token: accessToken,
      });

      const gmail = google.gmail({ version: "v1", auth: oauth2Client });

      await gmail.users.drafts.delete({
        userId: "me",
        id: draftId,
      });

      logger.info("Deleted Gmail draft", { userId, draftId });
      return ok(true);
    } catch (error) {
      logger.error(
        "Failed to delete Gmail draft",
        { userId, draftId },
        error as Error
      );
      return err(
        ActionErrors.internal(
          "Failed to delete Gmail draft",
          error as Error,
          "GoogleGmailService.deleteDraft"
        )
      );
    }
  }
}

